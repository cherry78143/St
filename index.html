<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>XDARK Private Chat — Single File</title>
<!-- Minimal modern styles -->
<style>
  :root{
    --bg:#071021; --card:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --glass: rgba(255,255,255,0.03);
    --radius:12px; color-scheme: dark;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#020617,#071021);color:#e6eef6}
  .wrap{max-width:1100px;margin:18px auto;display:grid;grid-template-columns:300px 1fr;gap:16px;padding:12px}
  @media(max-width:900px){.wrap{grid-template-columns:1fr} .left{order:2} .right{order:1}}
  .card{background:var(--card);border-radius:var(--radius);padding:14px;box-shadow:0 8px 24px rgba(0,0,0,0.6)}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:700}
  h1{margin:0;font-size:18px}
  .small{font-size:13px;color:var(--muted)}
  .user-row{display:flex;align-items:center;gap:12px}
  .avatar{width:44px;height:44px;border-radius:50%;background:#071428;display:flex;align-items:center;justify-content:center;font-weight:700}
  input,button,textarea,select{font:inherit}
  input[type="text"],input[type="email"],input[type="password"],textarea{width:100%;padding:10px;border-radius:10px;background:var(--glass);border:1px solid rgba(255,255,255,0.03);color:inherit}
  .btn{background:var(--accent);border:none;color:#021018;padding:8px 12px;border-radius:10px;cursor:pointer}
  .muted{color:var(--muted)}
  .searchbox{display:flex;gap:8px;margin-top:10px}
  .users{margin-top:12px;display:flex;flex-direction:column;gap:8px;max-height:380px;overflow:auto;padding-right:6px}
  .user-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;cursor:pointer}
  .user-item:hover{background:rgba(255,255,255,0.02)}
  .right{display:flex;flex-direction:column;gap:12px}
  .messages{flex:1;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:10px;max-height:520px}
  .msg{max-width:72%;padding:10px;border-radius:12px;background:rgba(255,255,255,0.03)}
  .me{align-self:flex-end;background:linear-gradient(90deg,var(--accent),#7c3aed);color:#021018}
  .composer{display:flex;gap:8px;padding-top:8px}
  .file-preview{max-width:160px;border-radius:8px;display:block;margin-top:8px}
  .call-panel{display:flex;gap:12px;align-items:center;margin-top:10px}
  video{background:#000;border-radius:10px;max-width:100%}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:999}
  .tiny{font-size:12px;color:var(--muted)}
</style>
</head>
<body>

<div class="wrap">
  <!-- LEFT: profile & user/search -->
  <div class="left">
    <div class="card">
      <div class="brand">
        <div class="logo">XD</div>
        <div>
          <h1>XDARK • Private Chat</h1>
          <div class="small muted">1:1 chat • Audio & Video</div>
        </div>
      </div>

      <hr style="border:0;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0">

      <div class="user-row">
        <div class="avatar" id="avatar">U</div>
        <div style="flex:1">
          <div id="displayName" class="small">Not signed in</div>
          <div id="displayEmail" class="tiny muted">—</div>
        </div>
        <div>
          <button id="signBtn" class="btn">Sign in</button>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="tiny muted">Set username</div>
        <div style="display:flex;gap:8px;margin-top:6px">
          <input id="usernameInput" placeholder="username (unique)" />
          <button id="saveUsername" class="btn">Save</button>
        </div>
        <div id="usernameMsg" class="tiny muted" style="margin-top:6px"></div>
      </div>

      <div style="margin-top:14px">
        <div class="tiny muted">Find user</div>
        <div class="searchbox">
          <input id="searchBox" placeholder="search by username or email" />
          <button id="searchBtn" class="btn">Search</button>
        </div>
        <div class="users" id="usersList"></div>
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="tiny muted">Account actions</div>
        <div class="tiny muted">Auth</div>
      </div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="openAuth" class="btn">Sign in / up</button>
        <button id="btnProfile" class="btn" style="background:#334155">Profile</button>
      </div>
      <div style="margin-top:12px" class="tiny muted">Tips: Click a user to start a private chat. Start audio/video from chat header.</div>
    </div>
  </div>

  <!-- RIGHT: chat & call -->
  <div class="right">
    <div class="card" id="chatCard" style="display:flex;flex-direction:column">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div id="chatTitle"><strong>Welcome</strong></div>
          <div id="chatSubtitle" class="tiny muted">Select a user to start private chat</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="btnVideo" class="btn" title="Start video call" style="display:none">Video</button>
          <button id="btnAudio" class="btn" title="Start audio call" style="display:none">Voice</button>
        </div>
      </div>

      <div class="messages" id="messages"></div>

      <div class="composer">
        <input id="msgInput" placeholder="Type message..." />
        <input type="file" id="fileInput" style="display:none" />
        <button id="attachBtn" class="btn" style="background:#334155">Attach</button>
        <button id="sendBtn" class="btn">Send</button>
      </div>
    </div>

    <!-- Call area -->
    <div class="card" id="callCard" style="display:none;flex-direction:column">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong id="callTitle">Call</strong></div>
        <div><button id="hangupBtn" class="btn" style="background:#ef4444">Hang up</button></div>
      </div>
      <div class="call-panel" style="margin-top:12px">
        <div style="flex:1">
          <div class="tiny muted">You</div>
          <video id="localVideo" autoplay muted playsinline style="height:240px;width:100%"></video>
        </div>
        <div style="flex:1">
          <div class="tiny muted">Remote</div>
          <video id="remoteVideo" autoplay playsinline style="height:240px;width:100%"></video>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- AUTH MODAL -->
<div id="authModal" class="modal" style="display:none">
  <div class="card" style="width:380px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Sign in / Sign up</strong></div>
      <div class="tiny muted">Firebase Auth</div>
    </div>
    <div style="margin-top:12px;display:flex;flex-direction:column;gap:8px">
      <input id="authEmail" type="email" placeholder="Email" />
      <input id="authPassword" type="password" placeholder="Password" />
      <div style="display:flex;gap:8px">
        <button id="emailSignIn" class="btn">Sign in</button>
        <button id="emailSignUp" class="btn" style="background:#334155">Sign up</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="googleSignIn" class="btn" style="background:#fff;color:#021018">Google</button>
        <button id="forgotBtn" class="btn" style="background:#0ea5a4">Forgot</button>
        <button id="closeAuth" class="btn" style="background:#6b7280">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- PROFILE MODAL -->
<div id="profileModal" class="modal" style="display:none">
  <div class="card" style="width:360px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Profile</strong></div>
      <div class="tiny muted">Update info</div>
    </div>
    <div style="margin-top:10px;display:flex;flex-direction:column;gap:8px">
      <input id="profileName" placeholder="Display name" />
      <input id="profilePhoto" placeholder="Photo URL (optional)" />
      <div style="display:flex;gap:8px;justify-content:flex-end">
        <button id="saveProfile" class="btn">Save</button>
        <button id="closeProfile" class="btn" style="background:#6b7280">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Firebase compat SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>

<script>
/* ---------- Use your Firebase project config here (from your message) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyCj1bt3rP1XcIbSfTUFhrkUrm9Li8ZB85A",
  authDomain: "xdark-8b6b0.firebaseapp.com",
  databaseURL: "https://xdark-8b6b0-default-rtdb.firebaseio.com",
  projectId: "xdark-8b6b0",
  storageBucket: "xdark-8b6b0.appspot.com",
  messagingSenderId: "12349294669",
  appId: "1:12349294669:web:836be375f5a28235823404"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
const storage = firebase.storage();

/* ---------- UI elements ---------- */
const signBtn = document.getElementById('signBtn');
const openAuth = document.getElementById('openAuth');
const authModal = document.getElementById('authModal');
const closeAuth = document.getElementById('closeAuth');
const emailSignIn = document.getElementById('emailSignIn');
const emailSignUp = document.getElementById('emailSignUp');
const googleSignIn = document.getElementById('googleSignIn');
const forgotBtn = document.getElementById('forgotBtn');
const authEmail = document.getElementById('authEmail');
const authPassword = document.getElementById('authPassword');

const avatarEl = document.getElementById('avatar');
const displayNameEl = document.getElementById('displayName');
const displayEmailEl = document.getElementById('displayEmail');
const usernameInput = document.getElementById('usernameInput');
const saveUsername = document.getElementById('saveUsername');
const usernameMsg = document.getElementById('usernameMsg');

const searchBox = document.getElementById('searchBox');
const searchBtn = document.getElementById('searchBtn');
const usersList = document.getElementById('usersList');

const msgInput = document.getElementById('msgInput');
const sendBtn = document.getElementById('sendBtn');
const messagesEl = document.getElementById('messages');
const attachBtn = document.getElementById('attachBtn');
const fileInput = document.getElementById('fileInput');

const btnVideo = document.getElementById('btnVideo');
const btnAudio = document.getElementById('btnAudio');
const callCard = document.getElementById('callCard');
const callTitle = document.getElementById('callTitle');
const hangupBtn = document.getElementById('hangupBtn');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

const openProfileBtn = document.getElementById('btnProfile');
const profileModal = document.getElementById('profileModal');
const closeProfile = document.getElementById('closeProfile');
const saveProfileBtn = document.getElementById('saveProfile');
const profileName = document.getElementById('profileName');
const profilePhoto = document.getElementById('profilePhoto');

let currentUser = null;
let selectedUser = null; // the user we are chatting with
let currentRoomId = null;
let messagesRef = null;

/* ------------------- Auth state ------------------- */
auth.onAuthStateChanged(async user => {
  currentUser = user;
  if (user) {
    // ensure user entry exists in DB for search
    const uRef = db.ref('users/'+user.uid);
    await uRef.update({
      uid: user.uid,
      email: user.email || null,
      displayName: user.displayName || (user.email ? user.email.split('@')[0] : 'User'),
      photoURL: user.photoURL || null,
      lastSeen: Date.now()
    });
    displayNameEl.textContent = user.displayName || (user.email ? user.email.split('@')[0] : 'User');
    displayEmailEl.textContent = user.email || '';
    avatarEl.textContent = (user.displayName||'U').slice(0,1).toUpperCase();
    signBtn.textContent = 'Sign out';
    document.getElementById('usernameInput').value = user.displayName || '';
  } else {
    displayNameEl.textContent = 'Not signed in';
    displayEmailEl.textContent = '';
    avatarEl.textContent = 'U';
    signBtn.textContent = 'Sign in';
    // cleanup selection
    selectedUser = null;
    setChatHeader();
  }
});

/* ---------- Auth UI handlers ---------- */
signBtn.addEventListener('click', ()=> {
  if (currentUser) auth.signOut();
  else authModal.style.display = 'flex';
});
openAuth.addEventListener('click', ()=> authModal.style.display = 'flex');
closeAuth.addEventListener('click', ()=> authModal.style.display = 'none');

emailSignUp.addEventListener('click', async ()=>{
  const email = authEmail.value.trim(); const pass = authPassword.value;
  if (!email || !pass) return alert('Enter email and password');
  try {
    const cred = await auth.createUserWithEmailAndPassword(email, pass);
    await cred.user.updateProfile({ displayName: email.split('@')[0] });
    alert('Account created');
    authModal.style.display = 'none';
  } catch(e){ alert('Sign up error: '+e.message) }
});
emailSignIn.addEventListener('click', async ()=>{
  const email = authEmail.value.trim(); const pass = authPassword.value;
  if (!email || !pass) return alert('Enter email and password');
  try {
    await auth.signInWithEmailAndPassword(email, pass);
    authModal.style.display = 'none';
  } catch(e){ alert('Sign in error: '+e.message) }
});
googleSignIn.addEventListener('click', async ()=>{
  const provider = new firebase.auth.GoogleAuthProvider();
  try {
    await auth.signInWithPopup(provider);
    authModal.style.display = 'none';
  } catch(e){ alert('Google sign in error: '+e.message) }
});
forgotBtn.addEventListener('click', async ()=>{
  const email = authEmail.value.trim();
  if (!email) return alert('Enter your email');
  try {
    await auth.sendPasswordResetEmail(email);
    alert('Reset email sent');
  } catch(e){ alert('Error: '+e.message) }
});

/* ---------- Profile ---------- */
openProfileBtn.addEventListener('click', ()=>{
  if (!currentUser) return alert('Sign in first');
  profileModal.style.display = 'flex';
  profileName.value = currentUser.displayName || '';
  profilePhoto.value = currentUser.photoURL || '';
});
closeProfile.addEventListener('click', ()=> profileModal.style.display = 'none');
saveProfileBtn.addEventListener('click', async ()=>{
  if (!currentUser) return alert('Sign in first');
  try {
    await currentUser.updateProfile({ displayName: profileName.value.trim() || currentUser.displayName, photoURL: profilePhoto.value.trim() || null });
    // update db entry
    await db.ref('users/'+currentUser.uid).update({ displayName: currentUser.displayName, photoURL: currentUser.photoURL });
    alert('Profile updated');
    profileModal.style.display = 'none';
  } catch(e){ alert('Profile update error: '+e.message) }
});

/* ---------- Username set (also used as search field) ---------- */
saveUsername.addEventListener('click', async ()=>{
  const name = usernameInput.value.trim();
  if (!currentUser) return alert('Sign in first');
  if (!name) return alert('Enter username');
  // check unique: we'll ensure no other user has same displayName (simple check)
  try {
    const q = await db.ref('users').orderByChild('displayName').equalTo(name).once('value');
    const val = q.val() || {};
    const keys = Object.keys(val || {});
    // if another user found who isn't current, reject
    if (keys.length > 0 && !(keys.length === 1 && keys[0] === currentUser.uid)) {
      usernameMsg.textContent = 'Username already taken';
      return;
    }
    await db.ref('users/'+currentUser.uid).update({ displayName: name, lastSeen: Date.now() });
    await currentUser.updateProfile({ displayName: name });
    usernameMsg.textContent = 'Saved';
    setTimeout(()=> usernameMsg.textContent = '', 2000);
  } catch(e){ alert('Error saving username: '+e.message) }
});

/* ---------- User search & listing ---------- */
async function searchUsers(q){
  usersList.innerHTML = '';
  if (!q) {
    // show recent users
    const snap = await db.ref('users').orderByChild('lastSeen').limitToLast(30).once('value');
    const rows = snap.val() || {};
    const arr = Object.values(rows).sort((a,b)=> (b.lastSeen||0)-(a.lastSeen||0));
    arr.forEach(renderUserItem);
    return;
  }
  // simple search: by displayName or email (prefix)
  const byName = await db.ref('users').orderByChild('displayName').startAt(q).endAt(q+"\uf8ff").once('value');
  const byEmail = await db.ref('users').orderByChild('email').startAt(q).endAt(q+"\uf8ff").once('value');
  const map = {};
  Object.values(byName.val()||{}).forEach(u=> map[u.uid]=u);
  Object.values(byEmail.val()||{}).forEach(u=> map[u.uid]=u);
  Object.values(map).forEach(renderUserItem);
}
function renderUserItem(u){
  const div = document.createElement('div');
  div.className = 'user-item';
  div.innerHTML = `<div style="width:44px;height:44px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center">${(u.displayName||u.email||'U')[0].toUpperCase()}</div>
    <div style="flex:1"><div><strong>${escapeHtml(u.displayName||'NoName')}</strong></div><div class="tiny muted">${escapeHtml(u.email||'')}</div></div>`;
  div.addEventListener('click', ()=> openPrivateChat(u));
  usersList.appendChild(div);
}

searchBtn.addEventListener('click', ()=> searchUsers(searchBox.value.trim()));
searchBox.addEventListener('keydown', e => { if (e.key==='Enter') searchUsers(searchBox.value.trim()); });

/* show recent users initially */
searchUsers('');

/* ---------- Private chat logic ---------- */
function roomIdFor(u1, u2){ // deterministic room id for pair
  const a = u1.uid < u2.uid ? u1.uid : u2.uid;
  const b = u1.uid < u2.uid ? u2.uid : u1.uid;
  return 'private_'+a+'_'+b;
}

async function openPrivateChat(userObj){
  if (!currentUser) return alert('Sign in to chat');
  selectedUser = userObj;
  currentRoomId = roomIdFor({uid:currentUser.uid}, userObj);
  setChatHeader();
  // attach messages
  if (messagesRef) messagesRef.off();
  messagesEl.innerHTML = '';
  messagesRef = db.ref('privateMessages/'+currentRoomId);
  messagesRef.limitToLast(500).on('child_added', snap => {
    const m = snap.val(); showMessage(m);
  });
  // update UI for call buttons
  btnVideo.style.display = 'inline-block'; btnAudio.style.display = 'inline-block';
}

/* header update */
function setChatHeader(){
  if (!selectedUser) {
    document.getElementById('chatTitle').innerHTML = '<strong>Welcome</strong>';
    document.getElementById('chatSubtitle').textContent = 'Select a user to start private chat';
    btnVideo.style.display = 'none'; btnAudio.style.display = 'none';
  } else {
    document.getElementById('chatTitle').innerHTML = `<strong>${escapeHtml(selectedUser.displayName||selectedUser.email||'User')}</strong>`;
    document.getElementById('chatSubtitle').textContent = 'Private 1:1 chat';
  }
}

/* show message */
function showMessage(m){
  const div = document.createElement('div');
  div.className = 'msg '+(m.from === currentUser.uid ? 'me':'');
  if (m.type === 'text') {
    div.innerHTML = `<div style="font-size:12px;color:var(--muted)">${escapeHtml(m.name||'')}</div><div style="margin-top:6px">${escapeHtml(m.text)}</div><div class="tiny muted" style="margin-top:6px">${new Date(m.ts).toLocaleTimeString()}</div>`;
  } else if (m.type === 'image') {
    div.innerHTML = `<div style="font-size:12px;color:var(--muted)">${escapeHtml(m.name||'')}</div><img src="${m.url}" class="file-preview" /><div class="tiny muted">${new Date(m.ts).toLocaleTimeString()}</div>`;
  } else if (m.type === 'system') {
    div.innerHTML = `<div class="tiny muted">${escapeHtml(m.text)}</div>`;
    div.style.textAlign='center';
  }
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

/* send message */
sendBtn.addEventListener('click', async ()=>{
  if (!currentRoomId) return alert('Open a private chat first');
  const text = msgInput.value.trim(); if (!text) return;
  const m = { type:'text', text, from: currentUser.uid, name: currentUser.displayName||currentUser.email, ts: Date.now() };
  await db.ref('privateMessages/'+currentRoomId).push(m);
  msgInput.value = '';
});

/* attach/upload */
attachBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if (!file) return;
  if (!currentRoomId) return alert('Open a chat first');
  const id = Date.now() + '_' + file.name;
  const path = `privateUploads/${currentRoomId}/${id}`;
  const upl = storage.ref(path).put(file);
  upl.on('state_changed', ()=>{}, err=> alert('Upload error: '+err.message), async ()=>{
    const url = await storage.ref(path).getDownloadURL();
    const m = { type:'image', url, from: currentUser.uid, name: currentUser.displayName||currentUser.email, ts: Date.now() };
    await db.ref('privateMessages/'+currentRoomId).push(m);
    fileInput.value = '';
  });
});

/* ---------- Simple WebRTC 1:1 signaling using Realtime DB ---------- */
/*
  Approach:
  - Calls stored under /privateCalls/{roomId}/{callId}
  - Caller writes offer -> callee listens and writes answer -> ICE candidates exchanged under candidates list
  - Works for 1:1. No TURN provided here (use TURN for better connectivity).
*/

let pc = null, localStream = null, remoteStream = null, callRef = null;

/* STUN only */
const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

btnVideo.addEventListener('click', ()=> initiateCall({video:true}));
btnAudio.addEventListener('click', ()=> initiateCall({video:false}));
hangupBtn.addEventListener('click', hangup);

async function initiateCall({video}){
  if (!selectedUser) return alert('Select a user to call');
  // get media
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video: video ? {width:640,height:480} : false });
  } catch(e){ return alert('Media error: '+e.message); }
  // show local
  localVideo.srcObject = localStream;
  // create RTCPeerConnection
  pc = new RTCPeerConnection(rtcConfig);
  remoteStream = new MediaStream();
  remoteVideo.srcObject = remoteStream;
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
  pc.ontrack = e => e.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
  pc.onicecandidate = e => {
    if (e.candidate && callRef) {
      callRef.child('candidates').push({ candidate: e.candidate.toJSON(), from: currentUser.uid });
    }
  };
  // create call node
  const roomCallsRef = db.ref('privateCalls/'+currentRoomId);
  callRef = roomCallsRef.push();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await callRef.set({ from: currentUser.uid, offer: offer.toJSON(), ts: Date.now() });

  // listen for answer & candidates
  callRef.on('value', snap => {
    const v = snap.val() || {};
    if (v.answer && !pc.remoteDescription) {
      pc.setRemoteDescription(new RTCSessionDescription(v.answer)).catch(()=>{});
    }
  });
  callRef.child('candidates').on('child_added', snap => {
    const c = snap.val();
    if (c && c.candidate && c.from !== currentUser.uid) {
      pc.addIceCandidate(new RTCIceCandidate(c.candidate)).catch(()=>{});
    }
  });
  callCard.style.display = 'flex';
  callTitle.textContent = 'Calling: '+(selectedUser.displayName||selectedUser.email);
}

/* Answer incoming calls: listen for calls for the current chat */
db.ref('privateCalls').on('child_added', snapRoom => {
  const room = snapRoom.key;
  // if it's for our current opened chat, watch calls inside it
  if (room !== currentRoomId) return;
  snapRoom.forEach(async callSnap => {
    const callKey = callSnap.key;
    const callData = callSnap.val();
    if (!callData || !callData.offer) return;
    // ignore if we created it
    if (currentUser && callData.from === currentUser.uid) return;
    // answer
    await answerCall(room, callKey, callData);
  });
});

/* When switching chat, re-setup listener for incoming calls by room (handled above as DB child_added) */

async function answerCall(roomId, callKey, callData){
  // create local media
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:true }).catch(()=>navigator.mediaDevices.getUserMedia({audio:true,video:false}));
  } catch(e){ console.warn('Media error', e); return; }
  localVideo.srcObject = localStream;
  pc = new RTCPeerConnection(rtcConfig);
  remoteStream = new MediaStream();
  remoteVideo.srcObject = remoteStream;
  localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  pc.ontrack = e => e.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
  pc.onicecandidate = e => {
    if (e.candidate) {
      db.ref('privateCalls/'+roomId+'/'+callKey+'/candidates').push({ candidate: e.candidate.toJSON(), from: currentUser.uid });
    }
  };
  // set remote desc
  await pc.setRemoteDescription(new RTCSessionDescription(callData.offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  // write answer
  await db.ref('privateCalls/'+roomId+'/'+callKey).update({ answer: answer.toJSON(), answeredBy: currentUser.uid });
  // listen for candidates
  db.ref('privateCalls/'+roomId+'/'+callKey+'/candidates').on('child_added', snap=>{
    const c = snap.val();
    if (c && c.candidate && c.from !== currentUser.uid) pc.addIceCandidate(new RTCIceCandidate(c.candidate)).catch(()=>{});
  });
  callCard.style.display = 'flex';
  callTitle.textContent = 'In call: '+(selectedUser? (selectedUser.displayName||selectedUser.email) : roomId);
}

/* hangup & cleanup */
function hangup(){
  if (pc) { pc.close(); pc = null; }
  if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
  if (remoteStream) { remoteStream.getTracks().forEach(t=>t.stop()); remoteStream = null; }
  if (callRef) { callRef.remove().catch(()=>{}); callRef.off(); callRef = null; }
  callCard.style.display = 'none';
  localVideo.srcObject = null; remoteVideo.srcObject = null;
}

/* Remove stale calls periodically (optional) */
setInterval(async ()=>{
  const calls = await db.ref('privateCalls').once('value');
  calls.forEach(roomSnap=>{
    roomSnap.forEach(callSnap=>{
      const v = callSnap.val();
      if (v && v.ts && Date.now()-v.ts > 1000*60*30) callSnap.ref.remove();
    });
  });
}, 1000*60*10);

/* ---------- Utilities ---------- */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }

/* Basic presence update every 60s */
setInterval(()=> {
  if (currentUser) db.ref('users/'+currentUser.uid).update({ lastSeen: Date.now() });
}, 60000);

/* Auto close modals on outside click */
document.querySelectorAll('.modal').forEach(mod => mod.addEventListener('click', e => { if (e.target===mod) mod.style.display='none' }));

/* Initial log */
console.log('XDARK private chat initialized');
</script>

</body>
</html>
