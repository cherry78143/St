<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Pro Chat + Video (Firebase)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { font-family: Inter,system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f4f7fb; }
    .app { max-width:1100px; margin:28px auto; }
    .card { border-radius:12px; box-shadow:0 6px 20px rgba(18,38,63,0.06); }
    .sidebar { min-width:280px; max-width:320px; }
    .chat-window { height:58vh; overflow:auto; padding:18px; background:linear-gradient(#fff,#fbfdff); border-radius:8px; }
    .message { display:flex; gap:12px; margin-bottom:12px; align-items:flex-end; }
    .message.me { flex-direction:row-reverse; text-align:right; }
    .bubble { max-width:72%; padding:10px 12px; border-radius:12px; background:#eef3ff; }
    .bubble.me { background:#2563eb; color:#fff; }
    .thumb { width:44px; height:44px; border-radius:50%; object-fit:cover; }
    .msg-img { max-width:260px; border-radius:8px; display:block; margin-top:8px; }
    .small-muted { color:#6b7280; font-size:13px; }
    .search-results { max-height:220px; overflow:auto; }
    .progress-sm { height:8px; }
    video { border-radius:8px; background:black; width:220px; height:140px; object-fit:cover; }
  </style>
</head>
<body>
  <div class="app container">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h4 class="m-0">Pro Chat â€¢ Video</h4>
      <div id="authArea"></div>
    </div>

    <div class="row g-3">
      <!-- left -->
      <div class="col-lg-4">
        <div class="card p-3 sidebar">
          <div id="profileArea" class="text-center mb-3">
            <img id="profilePhoto" src="" class="thumb mb-2 d-none"><div id="profileName" class="fw-semibold"></div>
            <div id="profileEmail" class="small-muted"></div>
          </div>

          <div class="mb-3">
            <label class="form-label small-muted">Search users</label>
            <div class="input-group">
              <input id="searchInput" class="form-control" placeholder="username or name...">
              <button id="searchBtn" class="btn btn-outline-secondary">Search</button>
            </div>
            <div id="searchResults" class="search-results mt-2"></div>
          </div>

          <hr/>

          <div>
            <div class="d-flex justify-content-between align-items-center mb-2">
              <strong>Rooms</strong><small class="small-muted">live</small>
            </div>
            <ul class="list-group" id="roomList">
              <li class="list-group-item list-group-item-action d-flex justify-content-between align-items-center" data-room="global"># Global
                <span class="badge bg-info text-dark">Public</span>
              </li>
            </ul>
          </div>

          <hr/>

          <div>
            <strong>Online / recent users</strong>
            <div id="usersList" class="mt-2 small-muted"></div>
          </div>
        </div>
      </div>

      <!-- right -->
      <div class="col-lg-8">
        <div class="card p-3">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <div>
              <h6 id="chatTitle" class="m-0"># Global</h6>
              <div id="chatSubtitle" class="small-muted">Public room</div>
            </div>
            <div class="d-flex gap-2">
              <button id="btnGlobal" class="btn btn-sm btn-outline-primary">Global</button>
              <button id="startCallBtn" class="btn btn-sm btn-success">Start Call</button>
              <button id="joinCallBtn" class="btn btn-sm btn-secondary">Join Call</button>
            </div>
          </div>

          <div id="chatWindow" class="chat-window mb-3"></div>

          <form id="messageForm" class="row gx-2 align-items-center">
            <div class="col-md-7">
              <input id="msgInput" class="form-control" placeholder="Type a message...">
            </div>
            <div class="col-md-3">
              <input id="msgImage" type="file" accept="image/*" class="form-control form-control-sm">
            </div>
            <div class="col-md-2 d-grid">
              <button id="sendBtn" class="btn btn-primary">Send</button>
            </div>

            <div class="col-12 mt-2">
              <div id="uploadProgress" class="progress progress-sm" style="display:none;">
                <div id="uploadBar" class="progress-bar" role="progressbar" style="width:0%">0%</div>
              </div>
              <div id="formStatus" class="small-muted mt-1"></div>
            </div>
          </form>

          <hr class="my-3">

          <div class="d-flex gap-3">
            <div>
              <div class="text-muted small mb-1">Local</div>
              <video id="localVideo" autoplay playsinline muted></video>
            </div>
            <div>
              <div class="text-muted small mb-1">Remote</div>
              <video id="remoteVideo" autoplay playsinline></video>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase modular SDK -->
  <script type="module">
    // ====== CONFIG - replace if needed ======
    const firebaseConfig = {
      apiKey: "AIzaSyC9DP2UT4_KKlPIzMxNSY1_sDwmOKJ2T3s",
      authDomain: "my-demo-63704.firebaseapp.com",
      databaseURL: "https://my-demo-63704-default-rtdb.firebaseio.com",
      projectId: "my-demo-63704",
      storageBucket: "my-demo-63704.firebasestorage.app",
      messagingSenderId: "309960709765",
      appId: "1:309960709765:web:d095e3bc26459e9bc57bec",
      measurementId: "G-C4B5GQLDME"
    };

    // ====== Imports ======
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import { getDatabase, ref as dbRef, set, push, onValue, get, child, remove, update } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    import { getStorage, ref as sRef, uploadBytesResumable, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";

    // ====== Init ======
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);
    const storage = getStorage(app);

    // ====== DOM ======
    const authArea = document.getElementById('authArea');
    const profilePhoto = document.getElementById('profilePhoto');
    const profileName = document.getElementById('profileName');
    const profileEmail = document.getElementById('profileEmail');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const searchResults = document.getElementById('searchResults');
    const roomList = document.getElementById('roomList');
    const usersList = document.getElementById('usersList');
    const chatWindow = document.getElementById('chatWindow');
    const chatTitle = document.getElementById('chatTitle');
    const chatSubtitle = document.getElementById('chatSubtitle');
    const msgInput = document.getElementById('msgInput');
    const msgImage = document.getElementById('msgImage');
    const sendBtn = document.getElementById('sendBtn');
    const messageForm = document.getElementById('messageForm');
    const uploadProgress = document.getElementById('uploadProgress');
    const uploadBar = document.getElementById('uploadBar');
    const formStatus = document.getElementById('formStatus');
    const btnGlobal = document.getElementById('btnGlobal');
    const startCallBtn = document.getElementById('startCallBtn');
    const joinCallBtn = document.getElementById('joinCallBtn');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    // ====== State ======
    let currentUser = null;
    let usersCache = {};
    let currentRoom = 'global'; // 'global' or conversation id like uid1_uid2
    let selectedFile = null;

    // ====== Helpers ======
    const esc = s => s ? String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])) : '';
    const timeFmt = ts => ts ? new Date(ts).toLocaleString() : '';

    // ====== Auth UI ======
    function renderAuthArea(){
      if (!currentUser) {
        authArea.innerHTML = `<button id="signInBtn" class="btn btn-outline-primary btn-sm">Sign in with Google</button>`;
        document.getElementById('signInBtn').onclick = signIn;
        profilePhoto.classList.add('d-none'); profileName.textContent=''; profileEmail.textContent='';
      } else {
        authArea.innerHTML = `<button id="signOutBtn" class="btn btn-outline-danger btn-sm">Sign out</button>`;
        document.getElementById('signOutBtn').onclick = () => signOut(auth);
        profilePhoto.src = currentUser.photoURL || ''; profilePhoto.classList.remove('d-none');
        profileName.textContent = currentUser.displayName || '';
        profileEmail.textContent = currentUser.email || '';
      }
    }

    async function signIn(){
      const provider = new GoogleAuthProvider();
      try {
        await signInWithPopup(auth, provider);
      } catch(e){
        alert('Sign-in error: ' + (e.message||e));
      }
    }

    // ====== User profile & list ======
    async function ensureProfile(user){
      const uRef = dbRef(db, 'users/' + user.uid);
      const snap = await get(uRef);
      const base = {
        uid: user.uid,
        displayName: user.displayName || '',
        email: user.email || '',
        photoURL: user.photoURL || '',
        username: (user.displayName || user.email || '').split(' ')[0].toLowerCase().replace(/[^a-z0-9_.-]/g,''),
        updatedAt: Date.now()
      };
      if (!snap.exists()) {
        await set(uRef, base);
        usersCache[user.uid] = base;
      } else {
        const existing = snap.val();
        const merged = { ...existing, ...base };
        if (!existing.username) merged.username = base.username;
        await update(uRef, merged);
        usersCache[user.uid] = merged;
      }
    }

    function listenUsers(){
      const uRef = dbRef(db, 'users');
      onValue(uRef, snap => {
        usersCache = snap.val() || {};
        renderUsersList();
      });
    }

    function renderUsersList(){
      const arr = Object.values(usersCache || {});
      usersList.innerHTML = arr.slice(0,20).map(u => `
        <div class="d-flex align-items-center justify-content-between mb-2">
          <div class="d-flex align-items-center">
            <img src="${esc(u.photoURL||'')}" class="thumb me-2" style="width:36px;height:36px;">
            <div><div style="font-weight:600">${esc(u.displayName||'')}</div><div class="small-muted">@${esc(u.username||'')}</div></div>
          </div>
          <div><button class="btn btn-sm btn-outline-primary start-chat" data-uid="${esc(u.uid)}">Chat</button></div>
        </div>
      `).join('');
      document.querySelectorAll('.start-chat').forEach(b => b.onclick = () => openPrivateChat(b.dataset.uid));
    }

    // ====== Search users ======
    searchBtn.onclick = doSearch;
    searchInput.onkeydown = e => { if (e.key==='Enter') doSearch(); };

    function doSearch(){
      const q = (searchInput.value||'').trim().toLowerCase();
      if (!q) { searchResults.innerHTML = '<div class="small-muted">Type username/name</div>'; return; }
      const results = Object.values(usersCache || {}).filter(u => ((u.username||'')+ ' ' + (u.displayName||'')).toLowerCase().includes(q));
      if (results.length === 0) { searchResults.innerHTML = '<div class="small-muted">No users found</div>'; return; }
      searchResults.innerHTML = results.map(u => `
        <div class="d-flex justify-content-between align-items-center border rounded p-2 mb-2">
          <div class="d-flex align-items-center">
            <img src="${esc(u.photoURL||'')}" class="thumb me-2" style="width:40px;height:40px;">
            <div><div style="font-weight:600">${esc(u.displayName||'')}</div><div class="small-muted">@${esc(u.username||'')}</div></div>
          </div>
          <div><button class="btn btn-sm btn-outline-primary start-chat" data-uid="${esc(u.uid)}">Chat</button></div>
        </div>
      `).join('');
      document.querySelectorAll('.start-chat').forEach(b => b.onclick = () => openPrivateChat(b.dataset.uid));
    }

    // ====== Rooms & switching ======
    btnGlobal.onclick = () => setRoom('global');
    roomList.addEventListener('click', e => {
      const li = e.target.closest('li[data-room]');
      if (!li) return;
      setRoom(li.dataset.room);
    });

    function setRoom(roomId){
      currentRoom = roomId;
      if (roomId === 'global') {
        chatTitle.innerText = '# Global';
        chatSubtitle.innerText = 'Public conversation';
      } else {
        const parts = roomId.split('_');
        const otherUid = parts[0] === currentUser.uid ? parts[1] : parts[0];
        const other = usersCache[otherUid] || {};
        chatTitle.innerText = other.displayName ? `@${other.username || other.displayName}` : 'Private';
        chatSubtitle.innerText = other.displayName ? `${other.displayName} â€¢ private` : 'Private chat';
      }
      listenMessages(roomId);
    }

    function openPrivateChat(otherUid){
      if (!currentUser) return alert('Sign in to chat');
      if (otherUid === currentUser.uid) return alert("Can't chat with yourself");
      const id = [currentUser.uid, otherUid].sort().join('_');
      // add room to list (if not present)
      if (!Array.from(roomList.querySelectorAll('li')).some(li => li.dataset.room === id)) {
        const li = document.createElement('li');
        li.className = 'list-group-item list-group-item-action';
        li.dataset.room = id;
        li.textContent = 'Private: ' + (usersCache[otherUid]?.displayName || 'User');
        roomList.appendChild(li);
      }
      setRoom(id);
    }

    // ====== Messages (Realtime DB) ======
    let currentMessagesRef = null;
    function listenMessages(roomId){
      chatWindow.innerHTML = '<div class="small-muted text-center py-3">Loading messagesâ€¦</div>';
      // detach old? onValue returns an unsubscribe only if we store it; for this demo we rely on single browser session
      const path = roomId === 'global' ? 'rooms/global/messages' : `private/${roomId}/messages`;
      currentMessagesRef = dbRef(db, path);
      onValue(currentMessagesRef, snap => {
        const val = snap.val() || {};
        renderMessages(val);
      });
    }

    function renderMessages(messagesObj){
      chatWindow.innerHTML = '';
      const keys = Object.keys(messagesObj || {});
      if (keys.length === 0) { chatWindow.innerHTML = '<div class="small-muted text-center py-3">No messages yet</div>'; return; }
      keys.sort((a,b) => (messagesObj[a].timestamp||0) - (messagesObj[b].timestamp||0));
      for (const k of keys) {
        const m = messagesObj[k];
        const isMe = currentUser && m.senderUid === currentUser.uid;
        const wrapper = document.createElement('div');
        wrapper.className = 'message ' + (isMe ? 'me' : '');
        wrapper.innerHTML = `
          <img class="thumb" src="${esc(m.senderPhoto||'')}" alt="">
          <div style="max-width:100%;">
            <div class="bubble ${isMe ? 'me' : ''}">
              <div style="font-weight:600">${esc(m.senderName||'')}</div>
              <div>${esc(m.text||'')}</div>
              ${m.image ? `<a href="${esc(m.image)}" target="_blank"><img class="msg-img" src="${esc(m.image)}"></a>` : ''}
            </div>
            <div class="small-muted mt-1">${timeFmt(m.timestamp)}</div>
          </div>
        `;
        if (isMe) {
          const del = document.createElement('button');
          del.className = 'btn btn-sm btn-outline-danger mt-2';
          del.style.fontSize = '12px';
          del.textContent = 'Delete';
          del.onclick = () => deleteMessage(k, m);
          wrapper.querySelector('div[style]').appendChild(del);
        }
        chatWindow.appendChild(wrapper);
      }
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // Delete message
    async function deleteMessage(key, msg) {
      if (!confirm('Delete message?')) return;
      const path = currentRoom === 'global' ? `rooms/global/messages/${key}` : `private/${currentRoom}/messages/${key}`;
      try {
        if (msg.imagePath) {
          await deleteObject(sRef(storage, msg.imagePath)).catch(()=>{});
        }
        await remove(dbRef(db, path));
      } catch(e){ alert('Delete failed: ' + (e.message||e)); }
    }

    // ====== Send message & upload image ======
    msgImage.addEventListener('change', e => selectedFile = e.target.files[0] || null);

    async function uploadFile(file) {
      return new Promise((resolve,reject) => {
        const path = `chat_images/${Date.now()}_${file.name.replace(/\s+/g,'_')}`;
        const storageRef = sRef(storage, path);
        const task = uploadBytesResumable(storageRef, file);
        uploadProgress.style.display = 'block';
        uploadBar.style.width = '0%';
        task.on('state_changed', snap => {
          const pct = Math.round((snap.bytesTransferred / snap.totalBytes)*100);
          uploadBar.style.width = pct + '%';
          uploadBar.innerText = pct + '%';
        }, err => {
          uploadProgress.style.display = 'none';
          reject(err);
        }, async () => {
          try {
            const url = await getDownloadURL(task.snapshot.ref);
            uploadProgress.style.display = 'none';
            resolve({ url, path });
          } catch(e) { reject(e); }
        });
      });
    }

    messageForm.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      if (!currentUser) return alert('Sign in to send');
      const text = (msgInput.value || '').trim();
      const file = selectedFile;
      if (!text && !file) return;
      sendBtn.disabled = true; formStatus.innerText = 'Sending...';
      try {
        let imageUrl = '', imagePath = '';
        if (file) {
          const res = await uploadFile(file);
          imageUrl = res.url; imagePath = res.path;
        }
        const payload = {
          senderUid: currentUser.uid,
          senderName: currentUser.displayName || currentUser.email || '',
          senderPhoto: currentUser.photoURL || '',
          text: text || '',
          image: imageUrl || '',
          imagePath: imagePath || '',
          timestamp: Date.now()
        };
        const path = currentRoom === 'global' ? 'rooms/global/messages' : `private/${currentRoom}/messages`;
        await push(dbRef(db, path), payload);
        msgInput.value = ''; msgImage.value = ''; selectedFile = null;
        formStatus.innerText = '';
      } catch(e){
        alert('Send failed: ' + (e.message||e));
      } finally {
        sendBtn.disabled = false; uploadProgress.style.display = 'none';
      }
    });

    // ====== WebRTC video call using Realtime DB for signaling ======
    const iceConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let pc = null, localStream = null, remoteStream = null, callId = null;

    async function prepareCamera(){
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
          localVideo.srcObject = localStream;
        } catch(e){ alert('Camera permission error: ' + (e.message||e)); throw e; }
      }
    }

    // Start call (creates call node, creates offer)
    startCallBtn.onclick = async () => {
      await prepareCamera();
      pc = new RTCPeerConnection(iceConfig);
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      // add local tracks
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      pc.ontrack = e => e.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));

      // create call entry
      const newCallRef = push(dbRef(db, 'calls'));
      callId = newCallRef.key;

      // candidate refs
      const offerCandidatesRef = dbRef(db, `calls/${callId}/offerCandidates`);
      const answerCandidatesRef = dbRef(db, `calls/${callId}/answerCandidates`);

      // send local ICE to DB
      pc.onicecandidate = e => {
        if (e.candidate) push(offerCandidatesRef, e.candidate.toJSON());
      };

      // create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await set(dbRef(db, `calls/${callId}/offer`), { sdp: offer.sdp, type: offer.type });

      // listen for answer
      onValue(dbRef(db, `calls/${callId}/answer`), async snap => {
        const a = snap.val();
        if (a && !pc.currentRemoteDescription) {
          await pc.setRemoteDescription({ sdp: a.sdp, type: a.type });
        }
      });

      // listen for answer candidates
      onValue(dbRef(db, `calls/${callId}/answerCandidates`), snap => {
        snap.forEach(childSnap => {
          const c = childSnap.val();
          pc.addIceCandidate(c).catch(() => {});
        });
      });

      alert('Call started. Share Call ID with other participant: ' + callId);
    };

    // Join call by ID
    joinCallBtn.onclick = async () => {
      const id = prompt('Enter Call ID to join');
      if (!id) return;
      callId = id;
      await prepareCamera();
      pc = new RTCPeerConnection(iceConfig);
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      pc.ontrack = e => e.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));

      // fetch offer
      const offerSnap = await get(dbRef(db, `calls/${callId}/offer`));
      if (!offerSnap.exists()) return alert('Call not found');
      const offer = offerSnap.val();
      await pc.setRemoteDescription({ sdp: offer.sdp, type: offer.type });

      // candidates refs
      const offerCandidatesRef = dbRef(db, `calls/${callId}/offerCandidates`);
      const answerCandidatesRef = dbRef(db, `calls/${callId}/answerCandidates`);

      // send answer ICE to DB
      pc.onicecandidate = e => { if (e.candidate) push(answerCandidatesRef, e.candidate.toJSON()); };

      // listen for offerCandidates and add
      onValue(offerCandidatesRef, snap => {
        snap.forEach(childSnap => {
          const c = childSnap.val();
          pc.addIceCandidate(c).catch(()=>{});
        });
      });

      // create answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await set(dbRef(db, `calls/${callId}/answer`), { sdp: answer.sdp, type: answer.type });

      // listen for additional answer candidates (added by callee? already handled)
      onValue(answerCandidatesRef, snap => {
        snap.forEach(childSnap => {
          const c = childSnap.val();
          pc.addIceCandidate(c).catch(()=>{});
        });
      });
    };

    // ====== Auth state handling ======
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      renderAuthArea();
      if (user) {
        await ensureProfile(user);
        listenUsers();
        setRoom('global'); // default
      } else {
        // not signed in
        chatWindow.innerHTML = '<div class="small-muted text-center py-3">Sign in to start chatting</div>';
      }
    });

    // initial UI
    renderAuthArea();
    chatWindow.innerHTML = '<div class="small-muted text-center py-3">Sign in to start chatting</div>';

    // ====== Small helper: add list item for global room click ======
    document.querySelector('li[data-room="global"]').onclick = () => setRoom('global');

  </script>
</body>
</html>
